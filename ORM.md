# [Prisma ORM](https://www.prisma.io)

This project uses Prisma as ORM library, to map our data model
to SQL queries.

## Installing Prisma

To start, use `npm` to install `prisma` package:

> Note: Unlike Express, we don't need type annotation package with Prisma

```shell
npm install --save-dev prisma;
```

This will give us `npx` script `prisma`, which we can verify:

```shell
npx prisma --version;
```

## Initialize Prisma Schema

Just as `package.json` is your project manifest, and `tsconfig.json` is TypeScript-specific
configuration, Prisma also has its own manifest files with `.prisma` extension and format,
called [Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema).

As the file extension implies, this file is not a JSON or other data interchange format - it
has its own synyax that you must follow.

The schema defines 3 entities: **(1) datasource**, i.e. database vendor,
**(2) generator**, i.e. schema-to-code generator, and **(3) the data models**,
which defines our database shape and the relationship.

Prisma main idea is that you declare your database manifest in the Schema,
and Prisma will then generate _Prisma Client_, a type-safe query builder.

The Prisma Client talks to the database and provides ORM mapping for us,
which our application code can then import and use to talk to the databases,
so we can just focus on writing application code.

> The Prisma-generated client (from the Schema) defaults `./node_modules/.prisma/client`

We can write these files manually, but it's best to let Prisma generate the templates for us.
To initialize the template with PostgreSQL as datasource, use the Prisma `npx` script:

```shell
# Generate a new Schema for PostgreSQL
npx prisma init --datasource-provider=postgresql
```

This creates a new top-level directory `prisma`, and generates a new Prisma Schema at `./prisma/schema.prisma`.

## [Define data model in the Schema](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model)

After the Schema is initialized, we can now define our data models. In this tutorial,
the models represent our SQL tables and their relationship, since our datasource is an SQL database.

> Prisma Schema can also define data models for No-SQL such as MongoDB

Let's first discuss our data models - in this tutorial, we will have 3 SQL tables:
(1) `users`, (2) `groups`, and (3) `clipboards`. Each clipboard (an entry in table `clipboards`) will
have its corresponding owner (a user), and each user can belong to 0-or-many groups.

Fields that will be auto-generated will be decorated with `@default`, which means that our
appication code won't have to come up with fields, when inserting entries via Prisma.

### Entities

All 3 entities use UUID strings as primary keys, which is auto-generated by Prisma
(via `uuid()` Prisma function), and all 3 have `createdAt` column, which is set to the write time
(via `now()` Prisma function).

The model name is singular [PascalCase](https://en.wikipedia.org/wiki/Camel_case),
and Prisma will map the Schema model name to SQL tables with plural all-lowercase table names.
For example, `model User` will be mapped to table `users`.

### Relations

In this tutorial, we have a one-to-one relationship for clipboard and user
(a clipboard can only have 1 user). We also have a many-to-many (M-N) relationship
for user-group (a user can be long to 1-or-more groups).

This can be expressed in Prisma Schema like so:

```prisma
model Clipboard {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String
  content   String?
  user      User     @relation(fields: [userId], references: [id])
  userId    String
}

model User {
  id         String   @id @default(uuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  email      String   @unique
  clipboards Clipboard[]
  groups     UserOnGroup[]
}

model UserOnGroup {
  id      String @id @default(uuid())
  user    User   @relation(fields: [userId], references: [id])
  userId  String
  group   Group  @relation(fields: [groupId], references: [id])
  groupId String
}

model Group {
  id        String   @id @default(uuid())
  createdAt DateTime @updatedAt
  updatedAt DateTime @default(now())
  name      String   @unique
  users     UserOnGroup[]
}
```

In addition to `model Clipboard`, `model User`, and `model Group`, we also have
a relation table to map M-N relationship `model UserOnGroup`.

Now our data models are ready, but we still don't have the Prisma Client.

## Generate the Prisma Client

To generate the Prisma Client, use `npm` to install `@prisma/client`. As part of
the install script, the installation invokes `npx` script `prisma generate`, which
read the Schema and builds a new client based on the Schema.

We will not use `--save-dev` option, since we need the client in our production environment
too. When we push our project to a server, it will pull down `@prisma/client` and
re-generate a new client that is optimized to the server.

> Each time our data model changes, we'll need to re-generate a new Prisma Client
> with `npx prisma generate`. The package installation, though, is required only once.

```shell
npm install @prisma/client;
```

> If your Schema was bad, the command above should report an error. Should this happen,
> update your Schema and generate the Client with:
>
> ```shell
> npx prisma generate;
> ```

After your Client is successfully generated, we are ready to use the Client in our app code.

## Using Prisma Client in our code

The following code imports `PrismaClient` generated from the step above and initializes
a TypeScript Prisma Client:

```typescript
import { PrismaClient } from "@prisma/client";

// Our ORM provider
const prisma = new PrismaClient();
```

All models are available as top-level object fields of variable `prisma`,
for example, the `users` table (`User` model) is represented in `prisma` as `prisma.user`.

### `create`

We can try inserting a new entry for model `User` with `prisma.user.create`:

```typescript
const newUser = await prisma.user.create({
  data: {
    email: "foo@bar.com",
    posts: [],
  },
});
```

The arguments to Prisma methods are usually objects, and for DB operation methods,
they usually have top-level key `data` for our entry data.

Other top-level keys are still related to the DB operations, but not our data.
For example, they might be used to fine-tune database performance metrics or behaviors.

### `findMany` and `findFirst`

To get all entries from a model, use `findMany` method:

```typescript
// All users in table `users`
const users = await prisma.user.findMany();

// First user the database found in the table, with 0 condition
const someUser = await prisma.user.findOne();
```

### [Filter and conditions](https://www.prisma.io/docs/concepts/components/prisma-client/filtering-and-sorting)

We can utilize the SQL `WHERE` clause with `where` object key:

```typescript
const threeYearsAgo = new Date(
  new Date().setFullYear(new Date().getFullYear() - 3),
);

// Old users created in the database before 3 years ago from now
const oldUsers = await prisma.user.findMany({
  where: {
    createdAt: {
      gte: threeYearsAgo,
    },
  },
});
```

### Prisma type definitions

You might be curious what type is variable `newUser` from the above `create` snippet.
Is it your application code's entity class `User`? Or is it untyped?

The answer is it is typed, but the type is not from your application code. When we generate
the client, the client also creates a new type for use just with Prisma. The type maps to
our Schema models. For example, Prisma type generated from `model User` might look like this:

```typescript
type User = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  email: string;
};
```

You can see that the post (`model User.clipboards`) is not included in this type. This is because
from the SQL table viewpoint, table `users` don't have column `clipboards`.
Instead, the relation is implemented in table `clipboards` as column `userId`, hence there's no
clipboards available from this SQL-based Prisma-generated type.

If you want to access the `newUser` clipboards, you will need Prisma extra helper types, which
will be returned automatically if you supply a `include` object key to `findMany`:

```typescript
const users = await prisma.user.findMany({
  include: { clipboards: true }, // The key `clipboards` is from the Schema model User
});
```
