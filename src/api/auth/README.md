# API authorization

Authorization is how our app authenticates its users
and protects some of its routes.

It is akin to passport verification when traveling abroad.

There are 2 main topics under this concept that are distinct,
yet connected:

1. Registration and logins

   > Storing user sensitive information like passwords deserves its
   > own topic

   Registration is when your user first signs up to your service.
   It generally requires a user ID, like an email, and a secret,
   credential e.g. a password.

   After registration, user can _login_ with their registered credentials,
   which in most website is by submitting our credentials. If the
   credentials could be verified, the user is then logged in.

   > Users can also rely on an external service, like Google Accounts,
   > to authenticate with web apps, but this is beyond the scope of
   > this tutorial

2. Authorization

   Authorization (auth) is allowing certain entities to access certain
   resources. For examples, users might be required to authenticate before
   they can access their private user profile.

   Some entities might have different access rights, for example, an admin
   would have more degree of privileges when accessing certain resources when
   compared to a normal user.

## JWT authentication

[JWT](https://en.wikipedia.org/wiki/JSON_Web_Token) is one of the most popular
strategy for authention. It is stateless by design, which means that it does not
store states, so features like logging out cannot be implemented entirely
using JWT.

JWT is a standardized JSON string token, which is generated by signing a certain
_payload_ with a _secret key_.

The resulting token contains all of the information about the JWT, including
the payload, the algorithms used to encode/decode the token, other metadata
like issuer and audience of the token, and token expiration.

In our app, when the users login, the server signs a new JWT with a simple
payload `{id: string, email: string}` with its secret key string.

The server returns the token to the client, which then attaches the token to
its subsequent HTTP request header `Authorization`

When users access protected resources, the server takes the token out of the
client's request header. If none is found, the server returns a
`401 Unauthorized` error.

If the token was found in the header, the server then decodes it with its
secret key, and if that went bad, also returns a `401` error. Expired tokens
will produce the same result.

If the token was successfully verified and decoded, the server stores the
reconstructed payload for its own use.

This means that if the token is good, then the client did not have to
authenticate again, or tell the server who it is, since the payload information
(by our own choice) already contains the `id` and `email` information.

## JWT middleware

Because our app requires many protected resources, so many API endpoints
need to have JWT authentication. It would be tiring to write the authorization
strategy in every endpoint handler, so instead of creating duplicate code,
we will instead use a middleware.

An Express middleware is basically a handler. Tntercepts a request,
does something with it, and passes the request on to the _next_ handler.

In our context, [our JWT authentication middleware `authenticateJwt`](./jwt.ts)
will intercept all incoming requests for protected routes, extracted JWTs from
the headers, and early-returns a `401` if authentication went bad without our
_next handler_ having to do anything.

If the authentication went through, the middleware decodes the payload from
the request, and passes it on to the _next handler_ by attaching it to the request.

The next handlers can then have access to the payload attached to the requests,
and uses the payload information as if those information came from the clients themselves.

This means our next handlers can know the user email without requiring the user to
send anything about his email, as this information was already extracted from JWTs
and attached to the request by the JWT middleware.

In other words, the next handlers can just look at the requests, and know all
of the JWT payload information.

### JWT logout

Because JWT is stateless, any live JWT issued will authenticate successfully.

To implement a logout feature, the server must be able to invalidate JWT tokens.
This is impossible via JWT alone, as the standard does not specify how to
retire a token.

Instead, we'll need to hack around, like creating a cached list of invalidated
tokens and having the middleware check each request's JWT token against the list.

Everytime a user logs out, our server pushes the JWT to the list and stores it
until its eventual expiration.
