# API authorization

Authorization is how our app authenticates its users
and protects some of its routes.

It is akin to passport verification when traveling abroad.

There are 2 main topics under this concept that are distinct,
yet connected:

1. Registration and logins

   > Storing user sensitive information like passwords deserves its
   > own topic.

   Registration is when your user first signs up to your service.
   It generally requires a user ID, like an email, and a secret,
   credential e.g. a password.

   After registration, user can _login_ with their registered credentials,
   which in most website is by submitting our credentials. If the
   credentials could be verified, the user is then logged in.

   > Users can also rely on an external service, like Google Accounts,
   > to authenticate with web apps, but this is beyond the scope of
   > this tutorial

2. Authorization

   Authorization (auth) is allowing certain entities to access certain
   resources. For examples, users might be required to authenticate before
   they can access their private user profile.

   Some entities might have different access rights, for example, an admin
   would have more degree of privileges when accessing certain resources when
   compared to a normal user.

## JWT authentication

[JWT](https://en.wikipedia.org/wiki/JSON_Web_Token) is one of the most popular
strategy for authentication.

It is stateless by design, which means that it does not
store states, so features like logging out cannot be implemented entirely
using JWT.

JWT is a standardized JSON string token, which is generated by signing a certain
_payload_ with a _secret key_.

The resulting token contains all of the information about the JWT, including
the payload, the algorithms used to encode/decode the token, other metadata
like issuer and audience of the token, and token expiration.

The information embedded in the token allows the token issuer to know
how to decode the token, as well as its expiration status.

In our app, when the users login, the server signs a new JWT with a simple
payload `{id: string, email: string}` with its secret key (supplied via env).

In the login response, the server returns the token to the client,
which then attaches the token to its subsequent HTTP request header
`Authorization Bearer <JWT string>`

When users access protected resources, the server takes the token out of the
client's request header and tries to decode it. If none is found,
the server returns a `401 Unauthorized` error.

If the token was found in the header, the server then decodes it with its
secret key, and if unsuccessful, returns a `401` error. Expired tokens
will produce the same result.

If the token was successfully verified and decoded, the server does something
with the reconstructed payload for its own use.

This means that if the token is good, then the client did not have to
authenticate again, or tell the server who it is, since the JWT already contains
authorization information (via _payload_, by our own choice) already contains
the `id` and `email` information.

## JWT middleware

Because our app requires many protected resources, so many API endpoints
need to have JWT authentication. It would be tiring to write the authorization
strategy in every endpoint handler, so instead of creating duplicate code,
we will instead use a middleware.

An Express middleware is basically a handler. Middleware handlers intercept
requests, do something with it, and passes the request on to the _next_ handler
if they think so.

In our context, [our JWT authentication middleware `authenticateJwt`](./jwt.ts)
will intercept all incoming requests for protected routes, extracts JWTs from
the headers, and early-returns a `401` if authentication went bad, all this without
our _next handler_ having to do anything.

If the authentication went through, the middleware decodes the payload from
the request, and passes it on to the _next handler_ by attaching it to the request.

The next handlers can then have access to the payload attached to the requests,
and uses the payload information as if those information came from the clients themselves.

This means our _next handlers_ can know the user email without requiring the user to
send anything about his email, as this information was already extracted from JWTs
and attached to the request by the JWT middleware before the request reaches
the _next handler_.

In other words, the _next handlers_ can just look at the requests, and know all
of the JWT payload information.

### JWT logout

Because JWT is stateless, any live JWT issued will authenticate successfully.

To implement a logout feature, the server must be able to invalidate JWT tokens.
This is impossible via JWT alone, as the standard does not specify how to
retire a token.

Instead, we'll need to hack around, like creating a cached list of invalidated
tokens and having the middleware check each request's JWT token against the list.

To implement this, everytime a user logs out, the server may add the token to the
list and stores it until its eventual expiration. If another request comes in with
the logged out JWT, the server finds it in the list and denies access with a `401`.
